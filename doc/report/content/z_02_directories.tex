%!TEX root = ../report.tex
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%                                                                 %
%%%%%     z_02_directories.tex                                        %
%%%%%                                                                 %
%%%%% Author:      Michael Muehlberghuber (<mbgh@iis.ee.ethz.ch>      %
%%%%% Created:     01.07.2012                                         %
%%%%% Description: A description of all files and directories         %
%%%%%              contained within this LaTeX framework.             %
%%%%%                                                                 %
%%%%%                                                                 %
%%%%% History:                                                        %
%%%%%%%%%%%%%%                                                        %
%%%%%                                                                 %
%%%%% 01-Jul-2012 (Michael Muehlberghuber - mbgh@iis.ee.ethz.ch):     %
%%%%% *) Created initial version.                                     %
%%%%%                                                                 %
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\chapter{\pulpino environment}

\subsection{Requirements}

You should have at least the following programs and tools installed:
\begin{itemize}
  \item \textbf{git} $\geq$ 2.4.8
  \item \textbf{ModelSim} in a version $\geq$ 10.2c
  \item \textbf{CMake} $\geq$ 2.8.0, if you want to use Ninja (a build framework compareable to Make) you need a CMake version that supports this ($\geq$ 3.1.0)
  \item \textbf{riscv-toolchain} if you do not want to use the advanced interrupt features you can go with the official version maintained by UCB\footnote{as}. Otherwise I recommend using the version maintained at ETHZ.
\end{itemize}
As the C shell is the de-facto standard in engineering I would highly recommend you to use it. This setup has not been tested with any other shell like for example bash.

\subsection{Directory Structure}

\begin{flushleft}
\dirtree{%
.1 /.
  .2 README \DTcomment{README file with a quick start guide.}.
  .2 ips\_list.txt \DTcomment{Listing of all ip cores that are used by the project}.
  .2 update-ips.py \DTcomment{Updates all IPs according to ip\_list.txt}.
  .2 ci \DTcomment{Folder containing scripts used by continuous integration}.
    .3 setup.csh \DTcomment{Setup scripts that initialize the CI environment}.
    .3 *.csh \DTcomment{Runs the corresponding tests}.
  .2 doc \DTcomment{Contains the actual source files of your report.}.
    .3 datasheet \DTcomment{\pulpino }.
    .3 api \DTcomment{Driver api description}.
    .3 report \DTcomment{Contains this report}.
  .2 fpga \DTcomment{This folder contains everything special needed for FPGA emulation}.
  .2 ips \DTcomment{Contains the IP cores used for \pulpino.}.
    .3 adv\_dbg\_if \DTcomment{Source of the Advanced Debug Unit (ADU)}.
    .3 apb \DTcomment{APB peripherals}.
      .4 apb\_event\_unit \DTcomment{APB Event and Interrupt Unit}.
      .4 apb\_fll\_if \DTcomment{FLL configuration interface}.
      .4 apb\_gpio \DTcomment{APB General Purpose I/O}.
      .4 apb\_i2c \DTcomment{APB I2C}.
      .4 apb\_pulpino \DTcomment{APB SoC Control for \pulpino}.
      .4 apb\_spi\_master \DTcomment{APB SPI Master}.
      .4 apb\_timer \DTcomment{APB Timer}.
      .4 apb\_uart \DTcomment{TL16C550 compatible UART implementation.}.
    .3 axi \DTcomment{AXI interconnect and AXI peripherals}.
      .4 axi2apb \DTcomment{AXI to APB adapter}.
      .4 axi\_mem\_if\_DP \DTcomment{AXI to memory adapter}.
      .4 axi\_node \DTcomment{AXI Bus}.
      .4 axi\_slice\_dc \DTcomment{Slices the AXI Bus and inserts registers}.
      .4 axi\_spi\_slave \DTcomment{AXI SPI Slave}.
    .3 or10n \DTcomment{Source of the RISCV core}.
    .3 riscv \DTcomment{Source of the OpenRISC core}.
    .3 scm \DTcomment{Standard Cell Memories}.
    .3 scripts \DTcomment{Scripts used for compiling the corresponding IPs}.
  .2 rtl \DTcomment{Contains glue logic and project specific RTL.}.    
    .3 components \DTcomment{Technology dependent standard cells and their behavioral counterparts}.
    .3 scripts  \DTcomment{Scripts used for compiling the corresponding RTL}.
    .3 top.sv \DTcomment{Top level entity}.
  .2 sw \DTcomment{Contains software for \pulpino.}.
    .3 apps \DTcomment{Here is the actual source code for every application.}.
    .3 libs \DTcomment{Libraries and HALs for \pulpino}.
    .3 ref \DTcomment{Contains linker script and c runtime initialization code.}.
    .3 utils \DTcomment{Contains scripts that are needed for simulation.}.
  .2 cmake\_configure.or1k.llvm.sh \DTcomment{Sample script to configure environment for LLVM and the OpenRISC core.}.
  .2 cmake\_configure.riscv.gcc.sh \DTcomment{Sample script to configure environment for GCC and the RISC-V core.}.
  .2 tb \DTcomment{Contains RTL testbench and helper packages needed.}.
  .2 vsim \DTcomment{Contains scripts needed for simulation.}.
    .3 scripts \DTcomment{Compile scripts - invoked by CMake.}.
    .3 tcl\_files \DTcomment{The actual scripts location to run the CMake target with desired configuration.}.
}
\end{flushleft}


\section{Getting started}
\label{sec:getting_started}

\pulpino is organized to use different git repositories for every IP. Start by checking out the main repository.

\begin{shellenv}
sh~> git clone git@iis-git.ee.ethz.ch:pulp-project/pulpino.git
\end{shellenv}

By invoking the \verb+update_ips.py+ Python script you start pulling all remaining IPs specified in the \verb+ips_list.txt+ file. 

\begin{shellenv}
sh~> ./update-ips.py
\end{shellenv}


After the script has successfully pulled all IPs you can start running simulations. The whole \pulpino project uses CMake as a meta build framework and make or ninja respectively as the main build framework. CMake supports out of tree builds. Create a folder somewhere in the project e.g. in the \verb+sw/+ subdirectory and copy the \verb+cmake\_configure.*.*sh+ (depending on the setup you'd like to run) into the newly created build directory.

\begin{shellenv}
sh~sw/> mkdir build
sh~sw/> cp cmake_configure.riscv.gcc.sh build/
\end{shellenv}

Change into that build directory and executed the shell script.

\begin{shellenv}
sh~sw/> cd build
sh~sw/build> ./cmake_configure.riscv.gcc.sh build
\end{shellenv}

If you are at ETH you probably need to prefix the shell script with \verb+riscv+.
Invoking that script starts the CMake configuration. It sets up all make/ninja targets and creates the necessary directory structure to run simulations. Before you can start you have to compile the RTL sources with ModelSim. We provide the following target to do so: 

\begin{shellenv}
sh~sw/build> make vcompile
\end{shellenv}

Based on how you initialized your build framework it builds the correct core automatically (depending on whether you used \verb+cmake_configure.riscv.gcc.sh+ or \verb+cmake_configure.or1k.llvm.sh+).

The final step in running a simulation comprises of invoking the program you want to run. Have a look at the \verb+sw/apps+ folder. You can see that every program is contained in its own uniquely named directory. CMake automatically creates a simulation target for each of those programs. For example if you want to run the helloworld program just type:

\begin{shellenv}
sh~sw/build> make helloworld.vsim
\end{shellenv}

You are as well given the possibility to run ModelSim without the GUI. To do so invoke your program with \textbf{.vsimc}. For example:

\begin{shellenv}
sh~sw/build> make helloworld.vsimc
\end{shellenv}

To use Ninja instead of make have a look at the configuration scripts. After you have reconfigured your environment with the new script just call ninja instead of make:

\begin{shellenv}
sh~sw/build> ninja helloworld.vsim
\end{shellenv}

The call to *.vsim generates all files necessary to run the simulation inside your current build folder. It therefore copies the application structure from the apps folder. All outputfiles are written to the corresponding app folder within the build folder. What maybe especially useful for debugging is the output of the coretracer. Every instruction that is executed by the core is put into the TODO:NAme file.

\subsection{Utilities}

As soon as you get more comfortable with the build environment you are probably going to want start developing application. In order to support you and make your life a bit easier we have implemented some utility targets.

To disassemble a program call the *.read target:

\begin{shellenv}
sh~sw/build> make helloworld.read
\end{shellenv}

Sometimes it is difficult to have an overview of the cores control flow. We support the possibility to annotate the core's tracer output with the section name from the disassembly. This prints some sort of stack trace to a separate file called TODO:filename inside the built folder. That feature can be particularly useful if you want to debug highly nested function calls. To annotate the core's trace call:

\begin{shellenv}
sh~sw/build> make helloworld.annotate
\end{shellenv}



%%% Local Variables:
%%% mode: latex
%%% TeX-master: "../report_template"
%%% End:
